<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPX Fastest Segment Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for file input button */
        .file-input-button {
            background-color: #4A5568; /* gray-700 */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: inline-block; 
        }
        .file-input-button:hover {
            background-color: #2D3748; /* gray-800 */
        }
        #gpxFile {
            display: none; /* Hide the default file input */
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f; /* A distinct blue for the spinner */
            animation: spin 1s ease infinite;
            margin: 20px auto; /* Center the spinner */
        }
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        /* Ensure table has nice spacing and borders */
        #resultsTable th, #resultsTable td {
            padding: 0.75rem; /* p-3 */
            border-bottom-width: 1px;
            border-color: #E5E7EB; /* gray-200 */
        }
        #resultsTable th {
            background-color: #F9FAFB; /* gray-50 */
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">

    <div class="bg-white p-6 sm:p-8 rounded-xl shadow-xl w-full max-w-2xl">
        <h1 class="text-2xl sm:text-3xl font-bold text-center text-gray-700 mb-6">Fastest Segment Analyzer</h1>

        <div class="mb-6 text-center">
            <label for="gpxFile" class="file-input-button">
                Select GPX File
            </label>
            <input type="file" id="gpxFile" accept=".gpx">
            <p id="fileName" class="text-sm text-gray-500 mt-2"></p>
        </div>

        <button id="analyzeButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 disabled:opacity-50">
            Analyze Track
        </button>

        <div id="loadingSpinner" class="hidden spinner"></div>

        <div id="messageArea" class="mt-4 text-center text-red-500 font-medium"></div>

        <div id="resultsArea" class="mt-6 hidden">
            <h2 class="text-xl font-semibold text-gray-700 mb-4 text-center">Fastest Segments</h2>
            <div class="overflow-x-auto rounded-lg shadow">
                <table id="resultsTable" class="w-full text-sm text-left text-gray-600">
                    <thead class="text-xs text-gray-700 uppercase bg-gray-50">
                        <tr>
                            <th scope="col" class="py-3 px-4">Segment</th>
                            <th scope="col" class="py-3 px-4">Time</th>
                            <th scope="col" class="py-3 px-4">Avg. Pace</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody">
                        </tbody>
                </table>
            </div>
            <p id="noSegmentsFoundMessage" class="text-center text-gray-500 mt-4 hidden"></p>
        </div>
    </div>

    <footer class="text-center text-gray-500 mt-8 text-sm">
        <p>&copy; 2025 GPX Analyzer. For demonstration purposes.</p>
    </footer>

    <script>
        // DOM Elements
        const gpxFileInput = document.getElementById('gpxFile');
        const analyzeButton = document.getElementById('analyzeButton');
        const messageArea = document.getElementById('messageArea');
        const resultsArea = document.getElementById('resultsArea');
        const resultsTableBody = document.getElementById('resultsTableBody');
        const fileNameDisplay = document.getElementById('fileName');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const noSegmentsFoundMessage = document.getElementById('noSegmentsFoundMessage');

        // Segment definitions (name for display, distance in kilometers)
        // User-provided list of segments
        const segmentDefinitions = [
                   { name: "1 km", distanceKm: 1.0 },
                   { name: "1 Mile", distanceKm: 1.60934 }, // 1.60934 km
                   { name: "2 km", distanceKm: 2.0 },
                   { name: "3 km", distanceKm: 3.0 },
                   { name: "2 Miles", distanceKm: 2 * 1.60934 }, // 3.21868 km
                   { name: "4 km", distanceKm: 4.0 },
                   { name: "3 Miles", distanceKm: 3 * 1.60934 }, // 4.82802 km
                   { name: "5 km", distanceKm: 5.0 },
                   { name: "6 km", distanceKm: 6.0 },
                   { name: "4 Miles", distanceKm: 4 * 1.60934 }, // 6.43736 km
                   { name: "7 km", distanceKm: 7.0 },
                   { name: "8 km", distanceKm: 8.0 },
                   { name: "5 Miles", distanceKm: 5 * 1.60934 }, // 8.04670 km
                   { name: "9 km", distanceKm: 9.0 },
                   { name: "6 Miles", distanceKm: 6 * 1.60934 }, // 9.65604 km
                   { name: "10 km", distanceKm: 10.0 },
                   { name: "11 km", distanceKm: 11.0 },
                   { name: "7 Miles", distanceKm: 7 * 1.60934 }, // 11.26538 km
                   { name: "12 km", distanceKm: 12.0 },
                   { name: "8 Miles", distanceKm: 8 * 1.60934 }, // 12.87472 km
                   { name: "13 km", distanceKm: 13.0 },
                   { name: "14 km", distanceKm: 14.0 },
                   { name: "9 Miles", distanceKm: 9 * 1.60934 }, // 14.48406 km
                   { name: "15 km", distanceKm: 15.0 },
                   { name: "16 km", distanceKm: 16.0 },
                   { name: "10 Miles", distanceKm: 10 * 1.60934 }, // 16.09340 km
                   { name: "17 km", distanceKm: 17.0 },
                   { name: "11 Miles", distanceKm: 11 * 1.60934 }, // 17.70274 km
                   { name: "18 km", distanceKm: 18.0 },
                   { name: "19 km", distanceKm: 19.0 },
                   { name: "12 Miles", distanceKm: 12 * 1.60934 }, // 19.31208 km
                   { name: "20 km", distanceKm: 20.0 },
                   { name: "13 Miles", distanceKm: 13 * 1.60934 }, // 20.92142 km
                   { name: "21 km", distanceKm: 21.0 },
                   { name: "21.0975 km (Half marathon)", distanceKm: 21.0975 },
                   { name: "22 km", distanceKm: 22.0 },
                   { name: "14 Miles", distanceKm: 14 * 1.60934 }, // 22.53076 km
                   { name: "23 km", distanceKm: 23.0 },
                   { name: "24 km", distanceKm: 24.0 },
                   { name: "15 Miles", distanceKm: 15 * 1.60934 }, // 24.14010 km
                   { name: "25 km", distanceKm: 25.0 },
                   { name: "16 Miles", distanceKm: 16 * 1.60934 }, // 25.74944 km
                   { name: "26 km", distanceKm: 26.0 },
                   { name: "27 km", distanceKm: 27.0 },
                   { name: "17 Miles", distanceKm: 17 * 1.60934 }, // 27.35878 km
                   { name: "28 km", distanceKm: 28.0 },
                   { name: "18 Miles", distanceKm: 18 * 1.60934 }, // 28.96812 km
                   { name: "29 km", distanceKm: 29.0 },
                   { name: "30 km", distanceKm: 30.0 },
                   { name: "19 Miles", distanceKm: 19 * 1.60934 }, // 30.57746 km
                   { name: "31 km", distanceKm: 31.0 },
                   { name: "32 km", distanceKm: 32.0 },
                   { name: "20 Miles", distanceKm: 20 * 1.60934 }, // 32.18680 km
                   { name: "33 km", distanceKm: 33.0 },
                   { name: "21 Miles", distanceKm: 21 * 1.60934 }, // 33.79614 km
                   { name: "34 km", distanceKm: 34.0 },
                   { name: "35 km", distanceKm: 35.0 },
                   { name: "22 Miles", distanceKm: 22 * 1.60934 }, // 35.40548 km
                   { name: "36 km", distanceKm: 36.0 },
                   { name: "37 km", distanceKm: 37.0 },
                   { name: "23 Miles", distanceKm: 23 * 1.60934 }, // 37.01482 km
                   { name: "38 km", distanceKm: 38.0 },
                   { name: "24 Miles", distanceKm: 24 * 1.60934 }, // 38.62416 km
                   { name: "39 km", distanceKm: 39.0 },
                   { name: "40 km", distanceKm: 40.0 },
                   { name: "25 Miles", distanceKm: 25 * 1.60934 }, // 40.23350 km
                   { name: "41 km", distanceKm: 41.0 },
                   { name: "26 Miles", distanceKm: 26 * 1.60934 }, // 41.84284 km
                   { name: "42 km", distanceKm: 42.0 },
                   { name: "42.195 km (Marathon)", distanceKm: 42.195 },
        ];

        // Event listener for file input change
        gpxFileInput.addEventListener('change', (event) => {
            messageArea.textContent = ''; 
            resultsArea.classList.add('hidden'); 
            noSegmentsFoundMessage.classList.add('hidden'); 
            if (event.target.files.length > 0) {
                fileNameDisplay.textContent = `Selected: ${event.target.files[0].name}`;
            } else {
                fileNameDisplay.textContent = '';
            }
        });

        // Event listener for the analyze button click
        analyzeButton.addEventListener('click', () => {
            const file = gpxFileInput.files[0];
            if (!file) {
                messageArea.textContent = 'Please select a GPX file first.';
                return;
            }

            analyzeButton.disabled = true;
            loadingSpinner.classList.remove('hidden');
            messageArea.textContent = ''; 
            resultsArea.classList.add('hidden'); 
            resultsTableBody.innerHTML = ''; 
            noSegmentsFoundMessage.classList.add('hidden');


            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const gpxContent = e.target.result;
                    const points = parseGPX(gpxContent); 

                    if (!points || points.length < 2) {
                        messageArea.textContent = 'Could not parse track points or track is too short.';
                        resetUI(); 
                        return;
                    }

                    setTimeout(() => {
                        const allResults = [];
                        let foundAnySegment = false; 
                        segmentDefinitions.forEach(segmentDef => {
                            const result = findFastestSegment(points, segmentDef.distanceKm);
                            allResults.push({ name: segmentDef.name, result: result });
                            if (result) { 
                                foundAnySegment = true;
                            }
                        });
                        displayMultipleResults(allResults, foundAnySegment); 
                        resetUI(); 
                    }, 50); 

                } catch (error) {
                    console.error("Error processing file:", error);
                    messageArea.textContent = `Error: ${error.message}`;
                    resetUI();
                }
            };
            reader.onerror = () => {
                messageArea.textContent = 'Error reading file.';
                resetUI();
            };
            reader.readAsText(file); 
        });

        function resetUI() {
            analyzeButton.disabled = false;
            loadingSpinner.classList.add('hidden');
        }

        function parseGPX(gpxString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxString, "application/xml");

            const parserError = xmlDoc.getElementsByTagName("parsererror");
            if (parserError.length > 0) {
                console.error("XML Parsing Error:", parserError[0].textContent);
                throw new Error("Invalid GPX file format. Check console for details.");
            }

            const trackpoints = xmlDoc.getElementsByTagName('trkpt');
            if (trackpoints.length === 0) {
                throw new Error("No track points (<trkpt>) found in GPX file.");
            }

            const points = [];
            for (let i = 0; i < trackpoints.length; i++) {
                const tp = trackpoints[i];
                const lat = parseFloat(tp.getAttribute('lat'));
                const lon = parseFloat(tp.getAttribute('lon'));
                const timeElement = tp.getElementsByTagName('time')[0];
                
                if (isNaN(lat) || isNaN(lon) || !timeElement) {
                    console.warn("Skipping trackpoint with missing lat, lon, or time:", tp.outerHTML);
                    continue; 
                }
                const time = new Date(timeElement.textContent);
                if (isNaN(time.getTime())) { 
                     console.warn("Skipping trackpoint with invalid time:", timeElement.textContent);
                    continue; 
                }
                points.push({ lat, lon, time });
            }
            points.sort((a, b) => a.time - b.time);
            return points;
        }

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; 
            const dLat = (lat2 - lat1) * Math.PI / 180; 
            const dLon = (lon2 - lon1) * Math.PI / 180; 
            const rLat1 = lat1 * Math.PI / 180; 
            const rLat2 = lat2 * Math.PI / 180; 

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(rLat1) * Math.cos(rLat2) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; 
        }

        function findFastestSegment(points, targetDistanceKm) {
            let fastestOverallTimeSeconds = Infinity;

            if (points.length < 2 || targetDistanceKm <= 0) {
                return null; 
            }

            for (let i = 0; i < points.length - 1; i++) {
                let currentSegmentDistanceKm = 0; 
                
                for (let j = i + 1; j < points.length; j++) {
                    const p_startOfLeg = points[j-1]; 
                    const p_endOfLeg = points[j];     

                    const legDistanceKm = haversineDistance(p_startOfLeg.lat, p_startOfLeg.lon, p_endOfLeg.lat, p_endOfLeg.lon);
                    const legTimeSeconds = (p_endOfLeg.time.getTime() - p_startOfLeg.time.getTime()) / 1000;

                    if (legTimeSeconds < 0) { 
                        console.warn("Negative time difference encountered between points. Check data integrity or sorting.", p_startOfLeg.time, p_endOfLeg.time);
                        continue; 
                    }
                    
                    const distanceAfterThisLegKm = currentSegmentDistanceKm + legDistanceKm;

                    if (distanceAfterThisLegKm >= targetDistanceKm) {
                        const timeFromSegmentStartTo_p_startOfLeg_Seconds = (p_startOfLeg.time.getTime() - points[i].time.getTime()) / 1000;
                        let currentSegmentTimeForTargetDistanceSeconds;

                        if (legDistanceKm === 0) { 
                            if (currentSegmentDistanceKm >= targetDistanceKm) {
                                currentSegmentTimeForTargetDistanceSeconds = timeFromSegmentStartTo_p_startOfLeg_Seconds;
                            } else {
                                break; 
                            }
                        } else {
                            const distanceNeededFromThisLeg = targetDistanceKm - currentSegmentDistanceKm;
                            const fractionOfLegNeeded = distanceNeededFromThisLeg / legDistanceKm;
                            const timeForNeededPartOfLegSeconds = fractionOfLegNeeded * legTimeSeconds;
                            currentSegmentTimeForTargetDistanceSeconds = timeFromSegmentStartTo_p_startOfLeg_Seconds + timeForNeededPartOfLegSeconds;
                        }
                        
                        if (currentSegmentTimeForTargetDistanceSeconds < fastestOverallTimeSeconds) {
                            fastestOverallTimeSeconds = currentSegmentTimeForTargetDistanceSeconds;
                        }
                        break; 
                    }
                    currentSegmentDistanceKm = distanceAfterThisLegKm;
                } 
            } 

            if (fastestOverallTimeSeconds === Infinity) {
                return null; 
            }
            return { fastestTime: fastestOverallTimeSeconds, totalDistanceKm: targetDistanceKm };
        }

        /**
         * Displays the results for multiple segments in a table.
         * Only rows for which a valid time was found will be displayed.
         * @param {Array<{name: string, result: {fastestTime: number, totalDistanceKm: number}|null}>} allResults - Array of results for each segment.
         * @param {boolean} foundAnySegmentInitially - True if at least one segment definition yielded a non-null result object from findFastestSegment.
         */
        function displayMultipleResults(allResults, foundAnySegmentInitially) {
            resultsTableBody.innerHTML = ''; // Clear previous results from the table body
            let actualRowsAdded = 0; // Counter for rows actually added to the table

            // If foundAnySegmentInitially is false, it means no segment processing yielded any result object.
            // This usually indicates the track is too short for any analysis based on defined segments.
            if (!foundAnySegmentInitially) {
                noSegmentsFoundMessage.textContent = `No segments could be calculated. The track might be too short or data is insufficient.`;
                noSegmentsFoundMessage.classList.remove('hidden');
                resultsArea.classList.add('hidden'); // Ensure table area is hidden
                return;
            }

            // If foundAnySegmentInitially is true, proceed to iterate and build table rows
            // for segments that have a valid result.
            allResults.forEach(item => {
                // A segment result is valid if item.result is not null.
                // findFastestSegment returns null if no segment of the target distance is found or time is Infinity.
                if (item.result) { 
                    const row = resultsTableBody.insertRow(); 
                    const cellName = row.insertCell();    
                    const cellTime = row.insertCell();    
                    const cellPace = row.insertCell();    

                    cellName.textContent = item.name;
                    cellName.className = 'py-2 px-4 font-medium text-gray-900 whitespace-nowrap'; 

                    // Since item.result is not null, item.result.fastestTime is a valid number.
                    const pacePerKm = item.result.fastestTime / item.result.totalDistanceKm; 
                    cellTime.textContent = formatDuration(item.result.fastestTime);
                    cellPace.textContent = formatPace(pacePerKm);
                    
                    cellTime.className = 'py-2 px-4'; 
                    cellPace.className = 'py-2 px-4'; 
                    actualRowsAdded++; // Increment counter for successfully added rows
                }
            });

            // After iterating through all potential segments, check if any rows were actually added to the table.
            if (actualRowsAdded > 0) {
                resultsArea.classList.remove('hidden'); // Show the results table
                messageArea.textContent = ''; // Clear any general error messages
                noSegmentsFoundMessage.classList.add('hidden'); // Hide the "no segments found" message
            } else {
                // This case implies that foundAnySegmentInitially might have been true (meaning some processing occurred),
                // but ultimately no valid segment times were found that could be displayed in the table.
                // (e.g., all item.result objects were null, which would contradict foundAnySegmentInitially being true
                // unless the logic in findFastestSegment or its usage changes).
                // This serves as a fallback message.
                noSegmentsFoundMessage.textContent = `Although the track was processed, no valid segment times were found to display.`;
                noSegmentsFoundMessage.classList.remove('hidden');
                resultsArea.classList.add('hidden'); // Ensure table area is hidden
            }
        }

        function formatDuration(totalSeconds) {
            if (isNaN(totalSeconds) || totalSeconds === Infinity || totalSeconds < 0) return "N/A";
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            return `${minutes}:${seconds.toString().padStart(2, '0')}`; 
        }

        function formatPace(secondsPerKm) {
            if (isNaN(secondsPerKm) || secondsPerKm === Infinity || secondsPerKm < 0) return "N/A";
            return `${formatDuration(secondsPerKm)} /km`;
        }

    </script>
</body>
</html>

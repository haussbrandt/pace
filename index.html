<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPX Fastest Segment Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for file input button */
        .file-input-button {
            background-color: #4A5568; /* gray-700 */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: inline-block; 
        }
        .file-input-button:hover {
            background-color: #2D3748; /* gray-800 */
        }
        #gpxFile {
            display: none; /* Hide the default file input */
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f; /* A distinct blue for the spinner */
            animation: spin 1s ease infinite;
            margin: 20px auto; /* Center the spinner */
        }
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        /* Ensure table has nice spacing and borders */
        #resultsTable th, #resultsTable td {
            padding: 0.75rem; /* p-3 */
            border-bottom-width: 1px;
            border-color: #E5E7EB; /* gray-200 */
        }
        #resultsTable th {
            background-color: #F9FAFB; /* gray-50 */
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">

    <div class="bg-white p-6 sm:p-8 rounded-xl shadow-xl w-full max-w-2xl">
        <h1 class="text-2xl sm:text-3xl font-bold text-center text-gray-700 mb-6">Fastest Segment Analyzer</h1>

        <div class="mb-6 text-center">
            <label for="gpxFile" class="file-input-button">
                Select GPX File
            </label>
            <input type="file" id="gpxFile" accept=".gpx">
            <p id="fileName" class="text-sm text-gray-500 mt-2"></p>
        </div>

        <button id="analyzeButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 disabled:opacity-50">
            Analyze Track
        </button>

        <div id="loadingSpinner" class="hidden spinner"></div>

        <div id="messageArea" class="mt-4 text-center text-red-500 font-medium"></div>

        <div id="resultsArea" class="mt-6 hidden">
            <h2 class="text-xl font-semibold text-gray-700 mb-4 text-center">Fastest Segments</h2>
            <div class="overflow-x-auto rounded-lg shadow">
                <table id="resultsTable" class="w-full text-sm text-left text-gray-600">
                    <thead class="text-xs text-gray-700 uppercase bg-gray-50">
                        <tr>
                            <th scope="col" class="py-3 px-4">Segment</th>
                            <th scope="col" class="py-3 px-4">Time</th>
                            <th scope="col" class="py-3 px-4">Avg. Pace</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody">
                        </tbody>
                </table>
            </div>
            <p id="noSegmentsFoundMessage" class="text-center text-gray-500 mt-4 hidden"></p>
        </div>
    </div>

    <footer class="text-center text-gray-500 mt-8 text-sm">
        <p>&copy; 2025 GPX Analyzer. For demonstration purposes.</p>
    </footer>

    <script>
        // DOM Elements
        const gpxFileInput = document.getElementById('gpxFile');
        const analyzeButton = document.getElementById('analyzeButton');
        const messageArea = document.getElementById('messageArea');
        const resultsArea = document.getElementById('resultsArea');
        const resultsTableBody = document.getElementById('resultsTableBody');
        const fileNameDisplay = document.getElementById('fileName');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const noSegmentsFoundMessage = document.getElementById('noSegmentsFoundMessage');

        // Segment definitions (name for display, distance in kilometers)
        // User-provided list of segments
        const segmentDefinitions = [
            { name: "100 m", distanceKm: 0.1 },
            { name: "200 m", distanceKm: 0.2 },
            { name: "400 m", distanceKm: 0.4 },
            { name: "1/2 Mile", distanceKm: 0.5 * 1.60934 }, // 0.80467 km
            { name: "1 km", distanceKm: 1.0 },
            { name: "1 Mile", distanceKm: 1.60934 },        // 1.60934 km
            { name: "2 km", distanceKm: 2.0 },
            { name: "3 km", distanceKm: 3.0 },
            { name: "2 Miles", distanceKm: 2 * 1.60934 },   // 3.21868 km
            { name: "4 km", distanceKm: 4.0 },
            { name: "3 Miles", distanceKm: 3 * 1.60934 },  // 4.828032 km 
            { name: "5 km", distanceKm: 5.0 },
            { name: "6 km", distanceKm: 6.0 },
            { name: "4 Miles", distanceKm: 4 * 1.60934 },  // 6.437376 km 
        ];

        // Event listener for file input change
        gpxFileInput.addEventListener('change', (event) => {
            messageArea.textContent = ''; 
            resultsArea.classList.add('hidden'); 
            noSegmentsFoundMessage.classList.add('hidden'); 
            if (event.target.files.length > 0) {
                fileNameDisplay.textContent = `Selected: ${event.target.files[0].name}`;
            } else {
                fileNameDisplay.textContent = '';
            }
        });

        // Event listener for the analyze button click
        analyzeButton.addEventListener('click', () => {
            const file = gpxFileInput.files[0];
            if (!file) {
                messageArea.textContent = 'Please select a GPX file first.';
                return;
            }

            analyzeButton.disabled = true;
            loadingSpinner.classList.remove('hidden');
            messageArea.textContent = ''; 
            resultsArea.classList.add('hidden'); 
            resultsTableBody.innerHTML = ''; 
            noSegmentsFoundMessage.classList.add('hidden');


            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const gpxContent = e.target.result;
                    const points = parseGPX(gpxContent); 

                    if (!points || points.length < 2) {
                        messageArea.textContent = 'Could not parse track points or track is too short.';
                        resetUI(); 
                        return;
                    }

                    setTimeout(() => {
                        const allResults = [];
                        let foundAnySegment = false; 
                        segmentDefinitions.forEach(segmentDef => {
                            const result = findFastestSegment(points, segmentDef.distanceKm);
                            allResults.push({ name: segmentDef.name, result: result });
                            if (result) { 
                                foundAnySegment = true;
                            }
                        });
                        displayMultipleResults(allResults, foundAnySegment); 
                        resetUI(); 
                    }, 50); 

                } catch (error) {
                    console.error("Error processing file:", error);
                    messageArea.textContent = `Error: ${error.message}`;
                    resetUI();
                }
            };
            reader.onerror = () => {
                messageArea.textContent = 'Error reading file.';
                resetUI();
            };
            reader.readAsText(file); 
        });

        function resetUI() {
            analyzeButton.disabled = false;
            loadingSpinner.classList.add('hidden');
        }

        function parseGPX(gpxString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxString, "application/xml");

            const parserError = xmlDoc.getElementsByTagName("parsererror");
            if (parserError.length > 0) {
                console.error("XML Parsing Error:", parserError[0].textContent);
                throw new Error("Invalid GPX file format. Check console for details.");
            }

            const trackpoints = xmlDoc.getElementsByTagName('trkpt');
            if (trackpoints.length === 0) {
                throw new Error("No track points (<trkpt>) found in GPX file.");
            }

            const points = [];
            for (let i = 0; i < trackpoints.length; i++) {
                const tp = trackpoints[i];
                const lat = parseFloat(tp.getAttribute('lat'));
                const lon = parseFloat(tp.getAttribute('lon'));
                const timeElement = tp.getElementsByTagName('time')[0];
                
                if (isNaN(lat) || isNaN(lon) || !timeElement) {
                    console.warn("Skipping trackpoint with missing lat, lon, or time:", tp.outerHTML);
                    continue; 
                }
                const time = new Date(timeElement.textContent);
                if (isNaN(time.getTime())) { 
                     console.warn("Skipping trackpoint with invalid time:", timeElement.textContent);
                    continue; 
                }
                points.push({ lat, lon, time });
            }
            points.sort((a, b) => a.time - b.time);
            return points;
        }

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; 
            const dLat = (lat2 - lat1) * Math.PI / 180; 
            const dLon = (lon2 - lon1) * Math.PI / 180; 
            const rLat1 = lat1 * Math.PI / 180; 
            const rLat2 = lat2 * Math.PI / 180; 

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(rLat1) * Math.cos(rLat2) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; 
        }

        function findFastestSegment(points, targetDistanceKm) {
            let fastestOverallTimeSeconds = Infinity;

            if (points.length < 2 || targetDistanceKm <= 0) {
                return null; 
            }

            for (let i = 0; i < points.length - 1; i++) {
                let currentSegmentDistanceKm = 0; 
                
                for (let j = i + 1; j < points.length; j++) {
                    const p_startOfLeg = points[j-1]; 
                    const p_endOfLeg = points[j];     

                    const legDistanceKm = haversineDistance(p_startOfLeg.lat, p_startOfLeg.lon, p_endOfLeg.lat, p_endOfLeg.lon);
                    const legTimeSeconds = (p_endOfLeg.time.getTime() - p_startOfLeg.time.getTime()) / 1000;

                    if (legTimeSeconds < 0) { 
                        console.warn("Negative time difference encountered between points. Check data integrity or sorting.", p_startOfLeg.time, p_endOfLeg.time);
                        continue; 
                    }
                    
                    const distanceAfterThisLegKm = currentSegmentDistanceKm + legDistanceKm;

                    if (distanceAfterThisLegKm >= targetDistanceKm) {
                        const timeFromSegmentStartTo_p_startOfLeg_Seconds = (p_startOfLeg.time.getTime() - points[i].time.getTime()) / 1000;
                        let currentSegmentTimeForTargetDistanceSeconds;

                        if (legDistanceKm === 0) { 
                            if (currentSegmentDistanceKm >= targetDistanceKm) {
                                currentSegmentTimeForTargetDistanceSeconds = timeFromSegmentStartTo_p_startOfLeg_Seconds;
                            } else {
                                break; 
                            }
                        } else {
                            const distanceNeededFromThisLeg = targetDistanceKm - currentSegmentDistanceKm;
                            const fractionOfLegNeeded = distanceNeededFromThisLeg / legDistanceKm;
                            const timeForNeededPartOfLegSeconds = fractionOfLegNeeded * legTimeSeconds;
                            currentSegmentTimeForTargetDistanceSeconds = timeFromSegmentStartTo_p_startOfLeg_Seconds + timeForNeededPartOfLegSeconds;
                        }
                        
                        if (currentSegmentTimeForTargetDistanceSeconds < fastestOverallTimeSeconds) {
                            fastestOverallTimeSeconds = currentSegmentTimeForTargetDistanceSeconds;
                        }
                        break; 
                    }
                    currentSegmentDistanceKm = distanceAfterThisLegKm;
                } 
            } 

            if (fastestOverallTimeSeconds === Infinity) {
                return null; 
            }
            return { fastestTime: fastestOverallTimeSeconds, totalDistanceKm: targetDistanceKm };
        }

        /**
         * Displays the results for multiple segments in a table.
         * Only rows for which a valid time was found will be displayed.
         * @param {Array<{name: string, result: {fastestTime: number, totalDistanceKm: number}|null}>} allResults - Array of results for each segment.
         * @param {boolean} foundAnySegmentInitially - True if at least one segment definition yielded a non-null result object from findFastestSegment.
         */
        function displayMultipleResults(allResults, foundAnySegmentInitially) {
            resultsTableBody.innerHTML = ''; // Clear previous results from the table body
            let actualRowsAdded = 0; // Counter for rows actually added to the table

            // If foundAnySegmentInitially is false, it means no segment processing yielded any result object.
            // This usually indicates the track is too short for any analysis based on defined segments.
            if (!foundAnySegmentInitially) {
                noSegmentsFoundMessage.textContent = `No segments could be calculated. The track might be too short or data is insufficient.`;
                noSegmentsFoundMessage.classList.remove('hidden');
                resultsArea.classList.add('hidden'); // Ensure table area is hidden
                return;
            }

            // If foundAnySegmentInitially is true, proceed to iterate and build table rows
            // for segments that have a valid result.
            allResults.forEach(item => {
                // A segment result is valid if item.result is not null.
                // findFastestSegment returns null if no segment of the target distance is found or time is Infinity.
                if (item.result) { 
                    const row = resultsTableBody.insertRow(); 
                    const cellName = row.insertCell();    
                    const cellTime = row.insertCell();    
                    const cellPace = row.insertCell();    

                    cellName.textContent = item.name;
                    cellName.className = 'py-2 px-4 font-medium text-gray-900 whitespace-nowrap'; 

                    // Since item.result is not null, item.result.fastestTime is a valid number.
                    const pacePerKm = item.result.fastestTime / item.result.totalDistanceKm; 
                    cellTime.textContent = formatDuration(item.result.fastestTime);
                    cellPace.textContent = formatPace(pacePerKm);
                    
                    cellTime.className = 'py-2 px-4'; 
                    cellPace.className = 'py-2 px-4'; 
                    actualRowsAdded++; // Increment counter for successfully added rows
                }
            });

            // After iterating through all potential segments, check if any rows were actually added to the table.
            if (actualRowsAdded > 0) {
                resultsArea.classList.remove('hidden'); // Show the results table
                messageArea.textContent = ''; // Clear any general error messages
                noSegmentsFoundMessage.classList.add('hidden'); // Hide the "no segments found" message
            } else {
                // This case implies that foundAnySegmentInitially might have been true (meaning some processing occurred),
                // but ultimately no valid segment times were found that could be displayed in the table.
                // (e.g., all item.result objects were null, which would contradict foundAnySegmentInitially being true
                // unless the logic in findFastestSegment or its usage changes).
                // This serves as a fallback message.
                noSegmentsFoundMessage.textContent = `Although the track was processed, no valid segment times were found to display.`;
                noSegmentsFoundMessage.classList.remove('hidden');
                resultsArea.classList.add('hidden'); // Ensure table area is hidden
            }
        }

        function formatDuration(totalSeconds) {
            if (isNaN(totalSeconds) || totalSeconds === Infinity || totalSeconds < 0) return "N/A";
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            return `${minutes}:${seconds.toString().padStart(2, '0')}`; 
        }

        function formatPace(secondsPerKm) {
            if (isNaN(secondsPerKm) || secondsPerKm === Infinity || secondsPerKm < 0) return "N/A";
            return `${formatDuration(secondsPerKm)} /km`;
        }

    </script>
</body>
</html>
